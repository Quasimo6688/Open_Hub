<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brick Breaker Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>
<body>
    <script>
        let ball;
let paddle;
let bricks = [];
let playingGame = false;
let youWin = false;
let winText;

function setup() {
  createCanvas(400, 400);
  ball = new Ball();
  paddle = new Paddle();
  winText = createP('');
  winText.position(10, 380);
  for (let j = 0; j < 5; j++) {
    for (let i = 0; i < 10; i++) {
      bricks.push(new Brick(createVector(brickW * i, 25 + brickH * j)));
    }
  }
}

function draw() {
  background(220);
  ball.display();
  paddle.display();
  if (playingGame) ball.update();
  if (ball.collides(paddle) || ball.collidesTop(paddle)) {
    ball.direction.y *= -1;
  }
  checkCollisions();
  displayWinText();
}

function Ball() {
  this.position = createVector(width / 2, height / 2);
  this.direction = createVector(1, 1);
  this.speed = 3;
  this.radius = 10;

  this.display = function() {
    fill(0);
    ellipse(this.position.x, this.position.y, this.radius * 2, this.radius * 2);
  };

  this.update = function() {
    this.position.x += this.direction.x * this.speed;
    this.position.y += this.direction.y * this.speed;
    if (this.position.x > width - this.radius || this.position.x < this.radius) {
      this.direction.x *= -1;
    }
    if (this.position.y < this.radius) {
      this.direction.y *= -1;
    }
    if (this.position.y > height) {
      playingGame = false;
      this.position = createVector(width / 2, height / 2);
    }
  };
  // ... (其他小球的函数)
}
// ... (继续小球的函数)
this.collides = function(sprite) {
  let left = sprite.position.x;
  let right = sprite.position.x + sprite.width;
  let top_ = sprite.position.y;
  let bottom = sprite.position.y + sprite.height;
  let collides = !(this.position.x + this.radius < left ||
    this.position.x - this.radius > right ||
    this.position.y + this.radius < top_ ||
    this.position.y - this.radius > bottom);
  return collides;
};

this.collidingSide = function(sprite) {
  let left = sprite.position.x;
  let right = sprite.position.x + sprite.width;
  let top_ = sprite.position.y;
  let bottom = sprite.position.y + sprite.height;
  let previousLeft = this.position.x - this.speed;
  let previousRight = this.position.x + this.speed;
  let previousTop = this.position.y - this.speed;
  let previousBottom = this.position.y + this.speed;
  if (previousRight < left || previousLeft > right) {
    if (previousBottom < top_) {
      return 'top';
    } else if (previousTop > bottom) {
      return 'bottom';
    }
  } else if (previousBottom < top_ || previousTop > bottom) {
    if (previousRight < left) {
      return 'left';
    } else if (previousLeft > right) {
      return 'right';
    }
  }
};

this.collidesTop = function(sprite) {
  let top_ = sprite.position.y;
  let bottom = sprite.position.y + sprite.height;
  return this.position.y + this.radius > top_ && this.position.y - this.radius < bottom && this.position.x > sprite.position.x && this.position.x < sprite.position.x + sprite.width;
};

function Paddle() {
  this.width = 100;
  this.height = 10;
  this.isMovingLeft = false;
  this.isMovingRight = false;
  this.speed = 5;
  this.position = createVector((width - this.width) / 2, height - 35);

  this.display = function() {
    fill(0);
    rect(this.position.x, this.position.y, this.width, this.height);
  };

  this.update = function() {
    if (this.isMovingRight) {
      this.move(1);
    } else if (this.isMovingLeft) {
      this.move(-1);
    }
  };

  this.move = function(direction) {
    this.position.x += direction * this.speed;
    this.position.x = constrain(this.position.x, 0, width - this.width);
  };
}
function Brick(position) {
  this.width = 40;
  this.height = 20;
  this.position = position;
  this.color = color(random(255), random(255), random(255));

  this.display = function() {
    fill(this.color);
    rect(this.position.x, this.position.y, this.width, this.height);
  };

  this.collides = function(ball) {
    let collides = !(ball.position.x + ball.radius < this.position.x ||
      ball.position.x - ball.radius > this.position.x + this.width ||
      ball.position.y + ball.radius < this.position.y ||
      ball.position.y - ball.radius > this.position.y + this.height);
    return collides;
  };
}

function checkCollisions() {
  for (let i = bricks.length - 1; i >= 0; i--) {
    let brick = bricks[i];
    if (brick.collides(ball)) {
      let collidingSide = ball.collidingSide(brick);
      if (collidingSide === 'top' || collidingSide === 'bottom') {
        ball.direction.y *= -1;
      } else if (collidingSide === 'left' || collidingSide === 'right') {
        ball.direction.x *= -1;
      }
      bricks.splice(i, 1);
      if (bricks.length === 0) {
        youWin = true;
        playingGame = false;
      }
    }
  }
}

function displayWinText() {
  if (youWin) {
    winText.html('You Win!');
  } else {
    winText.html('');
  }
}

function keyPressed() {
  if (key === 'ArrowLeft') {
    paddle.isMovingLeft = true;
  } else if (key === 'ArrowRight') {
    paddle.isMovingRight = true;
  } else if (key === ' ') {
    playingGame = !playingGame;
  }
}

function keyReleased() {
  if (key === 'ArrowLeft') {
    paddle.isMovingLeft = false;
  } else if (key === 'ArrowRight') {
    paddle.isMovingRight = false;
  }
}

    </script>
</body>
</html>
